# Тема: Система контролю версій Git та співпраця через GitHub


## Загальний опис теми

Загальний опис теми

Git — це розподілена система контролю версій (VCS, Version Control System), створена Лінусом Торвальдсом у 2005 році для розробки ядра Linux. Сьогодні Git є де-факто стандартом для контролю версій у програмному забезпеченні та використовується мільйонами розробників по всьому світу.
Система контролю версій дозволяє відстежувати зміни в коді з часом, повертатися до попередніх версій, працювати над проектом командою без конфліктів, експериментувати з новими функціями в ізольованих гілках, та багато іншого. Git зберігає повну історію проекту, що дозволяє відповісти на питання "хто, що, коли і чому змінив" у будь-який момент часу.
Розуміння Git є критично важливим для сучасних розробників, незалежно від спеціалізації. Це не просто інструмент для збереження коду — це фундамент для ефективної командної роботи, continuous integration/deployment, code review процесів та професійної розробки ПЗ.

# Мета заняття

### Що ви навчитеся робити:
- Розуміти основні концепції систем контролю версій
- Створювати та керувати Git репозиторіями
- Фіксувати зміни (commits) та працювати з історією
- Створювати та об'єднувати гілки (branches)
- Працювати з віддаленими репозиторіями (GitHub, GitLab)
- Співпрацювати з іншими розробниками через pull requests
- Вирішувати конфлікти злиття
- Використовувати SSH-ключі та токени безпечно
- Працювати з .gitignore та захищати конфіденційні дані

### Навички для майбутньої кар'єри:
- Версіонування коду в командній розробці
- Code review та collaboration workflows
- CI/CD integration
- Open source contribution
- Portfolio management через GitHub

## Мета заняття

Що ви навчитеся робити:

Розуміти основні концепції систем контролю версій
Створювати та керувати Git репозиторіями
Фіксувати зміни (commits) та працювати з історією
Створювати та об'єднувати гілки (branches)
Працювати з віддаленими репозиторіями (GitHub, GitLab)
Співпрацювати з іншими розробниками через pull requests
Вирішувати конфлікти злиття
Використовувати SSH-ключі та токени безпечно
Працювати з .gitignore та захищати конфіденційні дані


Навички для майбутньої кар'єри:

Версіонування коду в командній розробці
Code review та collaboration workflows
CI/CD integration
Open source contribution
Portfolio management через GitHub

## Контрольні питання з Git

1. Основи Git

1. Яка різниця між Git та GitHub?
 • Git — локальна система контролю версій.
 • GitHub — хостинг для Git-репозиторіїв + інструменти для командної роботи.

2. Що означає “розподілена” система контролю версій?

Кожен розробник має повну копію репозиторію з історією, а не лише “клієнт-серверну” частину.

3. Яка різниця між git init та git clone?
 • git init — створює порожній локальний репозиторій.
 • git clone — створює копію вже існуючого віддаленого репозиторію.

2. Staging Area та Commits

4. Що таке Staging Area і навіщо вона потрібна?

Місце, де файли готуються до коміту. Дозволяє вибирати, що саме увійде в коміт.

5. Яка різниця між git add . та git add -A?
 • git add . — додає зміни всередині поточної директорії.
 • git add -A — додає всі зміни у репозиторії (у т.ч. видалення).

6. Як написати гарне commit message?
 • Коротко (до 50 символів).
 • В наказовій формі (“Fix bug”, “Add login page”).
 • За потреби — опис у другому абзаці.

7. Як виправити останній коміт?

git commit --amend

Можна змінити і файли, і повідомлення.

3. Гілки та злиття

8. Що таке гілка в Git і чому вони “легковажні”?

Гілка — це рухомий вказівник на коміт. Вона легка, бо займає кілька байтів.

9. Яка різниця між git merge та git rebase?
 • merge — об’єднує історії, створює merge-коміт.
 • rebase — “переписує” історію, робить її лінійною.

10. Що таке fast-forward merge?

Merge без створення нового коміту — просто пересуває вказівник гілки вперед.

11. Коли виникають merge конфлікти і як їх уникнути?

Виникають, коли дві гілки змінили один і той самий фрагмент файлу.
Уникнення: частіші pull, дрібніші гілки, чіткі зони відповідальності.

12. Чому не можна робити rebase публічних комітів?

Бо це змінює історію, і іншим розробникам доведеться її “виправляти”.

4. Віддалені репозиторії

13. Що таке origin?

Стандартне ім’я для основного віддаленого репозиторію.

14. Яка різниця між git fetch та git pull?
 • fetch — отримує зміни, не зливаючи їх.
 • pull = fetch + merge (або rebase).

15. Що робить git push --force і чому це небезпечно?

Перезаписує історію на сервері → може знищити чужу роботу.

16. Як видалити віддалену гілку?

git push origin --delete branchname

5. Скасування змін

17. Різниця між git reset --soft, --mixed, --hard:
 • soft — скасовує коміти, залишає все staged.
 • mixed (default) — скасовує коміти, прибирає зі staging.
 • hard — скасовує все, включно зі змінами у файлах.

18. Різниця між git reset та git revert:
 • reset — змінює історію (небезпечно для публічних гілок).
 • revert — створює новий коміт, який “відкочує” зміни.

19. Як скасувати git add (видалити зі staging)?

git restore --staged <file>

20. Як повернути видалений файл?

git restore <file>

або з конкретного коміту:

git checkout <commit> -- <file>

6. Безпека

21. Що не повинно потрапляти в Git репозиторій?
 • Паролі, токени.
 • Конфіг із секретами.
 • Великі файли залежностей.
 • Build-артефакти.

22. Що робити якщо випадково закомітили пароль?
 1. Видалити пароль із файлів.
 2. Змінити його у сервісі.
 3. Переписати історію:

git filter-repo ...

 4. Force-push (тільки якщо знаєш наслідки).

23. HTTPS vs SSH для GitHub — що краще?
 • SSH — безпечніше, зручніше, без паролів.
 • HTTPS — підходить для початківців або корпоративних середовищ.

24. Що таке Personal Access Token і навіщо він потрібен?

Замінює пароль при доступі до GitHub API або HTTPS-пушу.

7. GitHub

25. Що таке Pull Request?

Запит на внесення змін у репозиторій: обговорення, рев’ю, тести.

26. Яка різниця між Issues та Pull Requests?
 • Issues — задачі, баги, ідеї.
 • PR — пропозиція змін у коді.

27. Що таке Fork і навіщо він потрібен?

Копія чужого репозиторію у ваш акаунт для роботи без доступу.

28. Що таке GitHub Actions?

CI/CD система GitHub — автоматизація тестів, деплоя, перевірок.

8. Best Practices

29. Як часто треба робити коміти?

Часто. Кожна логічно завершена зміна = один коміт.

30. Скільки часу має жити feature branch?

1–5 днів. Чим довше живе — тим більше конфліктів.

31. Як організувати git workflow в команді?

Популярні моделі:
 • GitHub Flow
 • Git Flow

• Trunk-based development
Важливо: код рев’ю + маленькі гілки + часті pull.

32. Чи треба комітити node_modules або інші залежності?

Ні. Вони мають бути у .gitignore. Завантажуються через npm/yarn.

